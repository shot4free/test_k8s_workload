#!/usr/bin/env bash

##############################
# wrapper script for running
# helm against this chart

set -euf -o pipefail
dir="$(cd "$(dirname "${0}")"; pwd)"

CHART="${CHART:-gitlab}"
NAME="${NAME:-gitlab}"
NAMESPACE="${NAMESPACE:-gitlab}"

export HELM_TILLER_LOGS=true
export HELM_TILLER_LOGS_DIR=${PWD}/tiller.log

declare -a kube_objects=(
    registry-certificate
    registry-httpsecret
    registry-storage
)

# Source common functions and variable exports
# that are common to all charts

COMMON_SCRIPT_PATH="${COMMON_SCRIPT_PATH:-/k8s-workloads/common.bash}"
common_registry_image="registry.gitlab.com/gitlab-com/gl-infra/k8s-workloads/common/k8-helm-ci:latest"
if [[ -r "$COMMON_SCRIPT_PATH" ]]; then
    source "$COMMON_SCRIPT_PATH"
else
    echo "Extracting common.bash from $common_registry_image..."
    docker pull "$common_registry_image" >/dev/null
    tmpfile=$(mktemp)
    container_id=$(docker create $common_registry_image)
    docker cp "$container_id:$COMMON_SCRIPT_PATH" "$tmpfile"
    source "$tmpfile"
    rm -f "$tmpfile"
fi

CHART_VERSION=${CHART_VERSION:-}
DEFINED_CHART_VERSION=${CHART_VERSION:-$(get_chart_version)}
echo -e "${_CYN}-- Using Chart Version: ${DEFINED_CHART_VERSION} --${_NORM}"

get_gitlab_chart() {
  local charts_dir=${1}
  pushd "$charts_dir"

  if [[ "$CHART_VERSION" != "$DEFINED_CHART_VERSION" ]]; then
    install_gitlab_chart_via_helm || install_gitlab_chart_via_s3
  else
    install_gitlab_chart_via_git
  fi

  popd
}

install_gitlab_chart_via_git() {
    echo -ne "${_YELLOW}Using git to get chart...${_NORM}\\n"
    mkdir "$extracted_charts_dir"
    git clone -b "$CHART_VERSION" https://gitlab.com/charts/gitlab.git "$extracted_charts_dir" >/dev/null
    helm repo add gitlab 'https://charts.gitlab.io/'
    pushd "$extracted_charts_dir"
    helm dependency update
    popd
}

install_gitlab_chart_via_helm() {
    echo -ne "${_CYN}Using helm to get chart...${_NORM}\\n"
    helm repo add gitlab 'https://charts.gitlab.io/' && \
    helm fetch --version "$DEFINED_CHART_VERSION" "gitlab/${CHART}" --untar --untardir "$charts_dir"
}

install_gitlab_chart_via_s3() {
      echo -e "${_YELLOW}Using chart directly from S3...${_NORM}"
      set -x
      curl "https://gitlab-charts.s3.amazonaws.com/${CHART}-${DEFINED_CHART_VERSION}.tgz" | tar xzC "$charts_dir"
      set +x
}

echo "Validating secrets.."
for secret in ${kube_objects[*]}; do
    if ! kubectl get secrets -n "$NAMESPACE" "${secret}" >/dev/null; then
        echo -e "${_BRED}Secret \"$secret\" is not yet set, are secrets configured properly?${_NORM}"
        exit 1
    fi
done

charts_dir=$(mktemp -d)
extracted_charts_dir="${charts_dir}/${CHART}"
manifests_dir="$dir/../manifests"
registry_static_ip=$(get_static_ip "registry-gke-${ENV}")

helm_opts_values=(
    "${HELM_OPTS_VALUES[@]}"
    "--set" "registry.service.loadBalancerIP=$registry_static_ip"
    "--set" "global.registry.bucket=gitlab-$ENV-registry"
)

case "$ACTION" in
    install|upgrade)
        get_gitlab_chart "$charts_dir"

        helm_opts=(
            "$extracted_charts_dir"
            "--namespace" "${NAMESPACE}"
            "${HELM_OPTS[@]}"
            "${HELM_OPTS_VALUES[@]}"
            "${helm_opts_values[@]}"
        )

        set -x
        if [[ $ACTION == "install" ]]; then
            helm tiller run helm install --name "$NAME" "${helm_opts[@]}"
        else
            tail --pid=$$ --retry --follow "${HELM_TILLER_LOGS_DIR}" &
            helm tiller run helm upgrade "$NAME" "${helm_opts[@]}" --atomic --wait --timeout 60
        fi
        ;;

    list)
        set -x
        helm tiller run helm list

        kubectl get secrets --namespace "${NAMESPACE}"
        ;;

    remove)
        echo -ne "${_BRED}!! You are about to remove the $CHART chart on $CLUSTER in $ENV ($PROJECT) !!${_NORM}\\n"
        echo -ne "press enter to continue."
        read -rp ""
        echo -e "${_CYN}continuing...${_NORM}"

        helm_opts=(
            "--purge" "$NAME"
            "${HELM_OPTS[@]}"
        )

        set -x
        helm tiller run helm del "${helm_opts[@]}"

        set +x
        # Remove secrets that were probably created manually per our documentation
        for item in ${kube_objects[*]}; do
          if [[ ${dry_run:-} != "true" ]]; then
            set -x
            kubectl delete --namespace "${NAMESPACE}" --filename "$item"
          else
            set +x
            echo "Would run: kubectl delete --namespace $NAMESPACE --filename $item"
          fi
        done
        ;;

    template)
        get_gitlab_chart "${charts_dir}"
        helm_opts=(
            "$extracted_charts_dir"
            "--output-dir" "$manifests_dir"
            "--name" "${NAME}"
            "--namespace" "$NAMESPACE"
            "${HELM_OPTS[@]}"
            "${helm_opts_values[@]}"
        )
        set -x
        helm tiller run helm template "${helm_opts[@]}"
        ;;
esac

set +x
rm -rf "${charts_dir:?}"
