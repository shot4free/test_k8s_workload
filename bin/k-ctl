#!/usr/bin/env bash
# vim: ai:ts=2:sw=2:et

##############################
# wrapper script for running
# helm against this chart

set -euf -o pipefail
dir="$(
  cd "$(dirname "${0}")"
  pwd
)"

CHART="${CHART:-gitlab}"

export HELM_TILLER_LOGS=true
export HELM_TILLER_LOGS_DIR=${PWD}/tiller.log

declare -a kube_objects=(
  registry-certificate
  registry-httpsecret
  registry-storage
)

# Source common functions and variable exports
# that are common to all charts

COMMON_SCRIPT_PATH="${COMMON_SCRIPT_PATH:-/k8s-workloads/common.bash}"
if [[ -r "$COMMON_SCRIPT_PATH" ]]; then
  source "$COMMON_SCRIPT_PATH"
else
  # Grab the CI image version from  the .gitlab-ci.yml
  _BBLK="\\033[1;30m"
  _NORM="\\033[0m"
  version=$(sed -E -e "s/[[:space:]]+CI_IMAGE_VERSION:[[:space:]]'(v[0-9\\.]+)'/\\1/" -e "t" -e "d" .gitlab-ci.yml)
  echo -e "${_BBLK}Sourcing version $version of the common shell script"
  echo -e "if you want to use a local version set COMMON_SCRIPT_PATH to the location of common.bash"
  echo -e "or update .gitlab-ci.yml to set a new version${_NORM}"
  echo ""
  source <(curl -s "https://gitlab.com/gitlab-com/gl-infra/k8s-workloads/common/raw/$version/bin/common.bash")
fi

NAME="${NAME:-gitlab${STAGE_SUFFIX}}"
NAMESPACE="${NAMESPACE:-gitlab${STAGE_SUFFIX}}"

CHART_VERSION=${CHART_VERSION:-}
DEFINED_CHART_VERSION=${CHART_VERSION:-$(get_chart_version)}
echo -e "${_CYN}-- Using Chart Version: ${DEFINED_CHART_VERSION} --${_NORM}"

get_gitlab_chart() {
  local charts_dir=${1}
  pushd "$charts_dir"

  if [[ "$CHART_VERSION" != "$DEFINED_CHART_VERSION" ]]; then
    install_gitlab_chart_via_helm || install_gitlab_chart_via_s3
  else
    install_gitlab_chart_via_git
  fi

  popd
}

install_gitlab_chart_via_git() {
  echo -ne "${_YEL}Using git to clone chart version \"${CHART_VERSION}\"...${_NORM}\\n"
  mkdir "$extracted_charts_dir"
  git clone -b "$CHART_VERSION" https://gitlab.com/gitlab-org/charts/gitlab.git "$extracted_charts_dir" >/dev/null
  helm repo add gitlab 'https://charts.gitlab.io/'
  pushd "$extracted_charts_dir"
  helm dependency update
  popd
}

install_gitlab_chart_via_helm() {
  echo -ne "${_CYN}Using helm to get chart...${_NORM}\\n"
  helm repo add gitlab 'https://charts.gitlab.io/' &&
    helm fetch --version "$DEFINED_CHART_VERSION" "gitlab/${CHART}" --untar --untardir "$charts_dir"
}

install_gitlab_chart_via_s3() {
  echo -e "${_YEL}Using chart directly from S3...${_NORM}"
  set -x
  curl -s "https://gitlab-charts.s3.amazonaws.com/${CHART}-${DEFINED_CHART_VERSION}.tgz" | tar xzC "$charts_dir"
  set +x
}

charts_dir=$(mktemp -d)
extracted_charts_dir="${charts_dir}/${CHART}"
manifests_dir="$dir/../manifests"
registry_static_ip=$(get_static_ip "registry-gke-${ENV}${STAGE_SUFFIX}")

helm_opts_values=(
  "${HELM_OPTS_VALUES[@]}"
  "--set" "registry.service.loadBalancerIP=$registry_static_ip"
  "--set" "global.registry.bucket=gitlab-$ENV-registry"
  "--set" "registry.authEndpoint=$GITLAB_ENDPOINT"
)

# Adds annotations for auto-devops
if [[ -n ${CI:-} ]]; then
  helm_opts_values+=(
    "--set" "registry.annotations.app\\.gitlab\\.com/app=$CI_PROJECT_PATH_SLUG"
    "--set" "registry.annotations.app\\.gitlab\\.com/env=$CI_ENVIRONMENT_SLUG"
    "--set" "global.deployment.annotations.app\\.gitlab\\.com/app=$CI_PROJECT_PATH_SLUG"
    "--set" "global.deployment.annotations.app\\.gitlab\\.com/env=$CI_ENVIRONMENT_SLUG"
  )
fi

helm_diff() {
  debug "-- Helm Diff --" "${_CYN}"
  helm_opts=(
    "--detailed-exitcode"
    "--suppress-secrets"
    "--namespace" "${NAMESPACE}"
    "--version" "$DEFINED_CHART_VERSION"
    "${helm_opts_values[@]}"
    "$NAME"
    "gitlab/${CHART}"
  )

  set -x +e
  helm tiller run helm diff upgrade "${helm_opts[@]}"
  RC=$?
  set +x -e
  if [[ $RC != 0 ]]; then
    debug "Changes found!" "${_YEL}"
  else
    debug "No changes found." "${_GRN}"
  fi
  debug "-------" "${_CYN}"
}

case "$ACTION" in
  install | upgrade)
    overview
    get_gitlab_chart "$charts_dir"

    helm_diff

    helm_opts=(
      "$extracted_charts_dir"
      "--namespace" "${NAMESPACE}"
      "${HELM_OPTS[@]}"
      "${helm_opts_values[@]}"
    )

    if [[ $ACTION == "install" ]]; then
      helm tiller run helm install --name "$NAME" "${helm_opts[@]}"
      verify_installed_secrets "${kube_objects[@]}"
    else
      verify_installed_secrets "${kube_objects[@]}"
      tail --pid=$$ --retry --follow "${HELM_TILLER_LOGS_DIR}" &
      helm tiller run helm upgrade "$NAME" "${helm_opts[@]}" --atomic --wait --timeout 300
    fi
    ;;

  list)
    set -x
    helm tiller run helm list

    kubectl get secrets --namespace "${NAMESPACE}"
    ;;

  remove)
    overview
    warn_removal

    helm_opts=(
      "--purge" "$NAME"
      "${HELM_OPTS[@]}"
    )

    set -x
    helm tiller run helm del "${helm_opts[@]}"
    set +x

    # Remove secrets by removing gitlab-secrets release via helmfile
    if [[ ${dry_run:-} != "true" ]]; then
      helmfile -e "${ENV}" delete --purge
    else
      echo "Would run: helmfile -e ${ENV} delete --purge"
    fi
    ;;

  template)
    overview
    get_gitlab_chart "${charts_dir}"
    helm_opts=(
      "$extracted_charts_dir"
      "--output-dir" "$manifests_dir"
      "--name" "${NAME}"
      "--namespace" "$NAMESPACE"
      "${HELM_OPTS[@]}"
      "${helm_opts_values[@]}"
    )
    set -x
    helm tiller run helm template "${helm_opts[@]}"
    set +x
    verify_installed_secrets "${kube_objects[@]}"
    ;;
esac

set +x
rm -rf "${charts_dir:?}"
